#summary Implementing a reference data source

= !MyDas Tutorial - Reference Data Sources =

In this tutorial we will explain how to create a reference data source.This tutorial assumes that you are familiarized with the basic concepts of implementing data sources in !MyDas. It will reuse the same example as in the [MyDASTutorial Basic Tutorial].


== A Reference Server ==

!MyDas also allows to implement a data source that provides the sequence as a reference for other data sources, including itself because in !MyDas a reference server it is by inheritance an annotation data source.

in the [MyDASTutorial Basic Tutorial] we used the datasource [http://mydas.googlecode.com/svn/trunk/mydas/MyDasTemplate/src/main/java/uk/ac/ebi/mydas/examples/GFFFileDataSource.java GFFFileDataSource.java], which used the parser [http://mydas.googlecode.com/svn/trunk/mydas/MyDasTemplate/src/main/java/uk/ac/ebi/mydas/examples/GFF2Parser.java GFF2Parser.java] to process a GFF file and distribute it through DAS. Here we will extend that data source to provide a reference for the annotated sequences. 

The sequences will be provided in a Fasta file and therefore we have to start by processing that kind of files. In order to do that lets create a parser class for that kind of file. First create a file called FastaParser in the same package than the rest of the tutorial classes. This parser will read the file and for each sequence it will create an instance of DasSequence, and the set will be store as a hash table using the Ids as the keys, to make easy any future access.

The constructor of the class is going to receive and InputStream with the content of the file and the file name for versioning purposes, it will also initializes a file Scanner to read the file and the HashMap to store the sequences:
{{{
	private Scanner scanner;
	private Map<String,DasSequence> sequences;
	private String fileName;
	public FastaParser(InputStream fastaDoc, String fileName){
		this.fileName=fileName;
		scanner= new Scanner(fastaDoc);
		sequences =new HashMap<String,DasSequence>();
	}
}}}
To start the parsing process creates a method like this:
{{{
	public Map<String,DasSequence> parse() throws Exception{
		this.processLineByLine();
		return sequences;
	}
}}}
The `processLineByLine` just uses the scanner to go line by line calling `processLine` with the content of each line:
{{{
	private final void processLineByLine() throws Exception{
		try {
			while ( scanner.hasNextLine() ){
				processLine( scanner.nextLine() );
			}
		} finally {
			scanner.close();
		}
	}
}}}
The key of this parsing is in the `processLine` method. Here we classify he lines into 2, the ones starting by `>` and the rest. if is not starting by `>` means that the line is part of the current sequence, so we just concat it to a private String called `currentSequence`. 
In other case, there are also 2 cases: The first `>` of the whole file or subsequent ones, for the first sequence we just store in memory the currentHeader and initialize the currentSequence to the empty String. ad then every time it founds a new sequence(line starting by`>`) it uses the temporary header and sequence to create a DasSequence and added to the HashMap:
{{{
	private void processLine(String aLine) throws Exception{
		if (aLine.startsWith(">")){
			if (currentSequence!=null){
				String id=currentHeader.split(" ")[0];
				sequences.put(id,new DasSequence(id, currentSequence, 1, fileName, currentHeader));
			}
			currentHeader=aLine.substring(1).trim();
			currentSequence="";
		}else 
			currentSequence+=aLine.trim();
	}
}}}

After the whole file has been process the last sequence and header are still in memory and haven't been added to the HashMap, therefore the `processLineByLine` have to be edited to add this sequence:
{{{
	private final void processLineByLine() throws Exception{
		try {
			while ( scanner.hasNextLine() ){
				processLine( scanner.nextLine() );
			}
			String id=currentHeader.split(" ")[0];
			sequences.put(id,new DasSequence(id, currentSequence, 1, fileName, currentHeader));
		} finally {
			scanner.close();
		}
	}
}}}