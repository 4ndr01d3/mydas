#summary how to implement a reference server + entry points and maxbins capabilities
#labels Phase-Support

= !MyDas Tutorial - Other Capabilities =

In this tutorial we will explain how to create a reference data source that implements other capabilities included in DAS but that are optional, and because of that have been ignored in the other tutorials. This tutorial assumes that you have comleted the [MyDASTutorial3rdPart Advanced Tutorial] some of the methods developed there are going to be reused here.

== A reference Server ==

!MyDas also allows to implement a data source that provides the sequence as a reference for other data sources, including itself because in !MyDas a reference server it is by inheritance an annotation data source.

Let's start by making a copy of the data source created in the [MyDASTutorial3rdPart Advanced Tutorial], call it !EnsemblTestReferenceDataSource.java 
Change the Interface to implement from !RangeHandlingAnnotationDataSource to !ReferenceDataSource:

{{{
public class EnsemblTestReferenceDataSource implements ReferenceDataSource
}}}

This interfase force us to implement the method `getSequence`:
{{{
	public DasSequence getSequence(String segmentId) throws BadReferenceObjectException, DataSourceException {
		return null;
	}
}}}

To get the sequence we have to query the database, therefore we will edit the Java class that is controlling the DB connection: !EnsemblTestManager.java; Create a new method called getSequence with a signature as:
{{{
public DasSequence getSequence(String segmentId)
}}}
The sequence information in the Ensembl database is in the table `dna` but it requires the `seq_region_id` which in tha case of chromosomes can be found in the table seq_region with a query like `SELECT * FROM seq_region WHERE coord_system_id = 2;`; from there we can create a combined SQL like:
{{{
SELECT * FROM chromosome WHERE name=5;
}}}
And then our method will be something like:
{{{
	public DasSequence getSequence(String segmentId) throws DataSourceException, BadReferenceObjectException {
		DasSequence seq=null;
		String sql="";
		sql="SELECT * FROM chromosome WHERE name="+segmentId;
		try {
			Statement s = connection.createStatement ();
			s.executeQuery (sql);
			ResultSet rs = s.getResultSet ();
			if (rs.next ()) {
				seq= new DasSequence(segmentId,rs.getString("SEQUENCE"),1,"homo_sapiens_core_56_37a", "Chromosome "+segmentId);
			}else{
				throw new BadReferenceObjectException("The segment ["+segmentId+"] was not found in this reference server", segmentId);
			}
			rs.close ();
			s.close ();
		} catch (SQLException e) {
			throw new DataSourceException("Problems executing the sql query",e);
		}
		return seq;
	}

}}}

And then, the implementation of the method in the data source is as simple as:
{{{
	public DasSequence getSequence(String segmentId) throws BadReferenceObjectException, DataSourceException {
		return ensembl.getSequence(segmentId);
	}
}}}

Now that we have this is just a matter of registering this data source in the !MyDas configuration file, as in previous examples edit the file `[MyDasTemplate]/src/main/webapp/MydasServerConfig.xml` and add a data source. The added data source should look similar to:
{{{
        <datasource uri="ensemblReferenceTest"
                    title="ensemblReferenceTest"
                    description="Reference data source from ensembl database"
                    doc_href="http://mydas.googlecode.com/svn/trunk/mydas/MyDasTemplate/src/main/java/uk/ac/ebi/mydas/examples">
			<maintainer email="youremail@server.com" />

			<version uri="ensemblReferenceTest" created="2011-02-08">
	            <class>uk.ac.ebi.mydas.examples.EnsemblTestReferenceDataSource</class>
				<coordinates 	uri="CS_DS94"
								source="Gene_ID"
								authority="Ensembl"
								taxid="9606"
								test_range="ENSG00000160916">Ensembl,Gene_ID,Homo sapiens</coordinates>
				<capability	type="das1:sources"
						query_uri="http://localhost:8080/das/examplegff" />
				<capability	type="das1:types"
						query_uri="http://localhost:8080/das/examplegff/types" />
				<capability	type="das1:features"
						query_uri="http://localhost:8080/das/examplegff/features" />
				<capability	type="das1:feature-by-id"
						query_uri="http://localhost:8080/das/examplegff/features" />
				<capability	type="das1:stylesheet"
						query_uri="http://localhost:8080/das/examplegff/stylesheet" />
				<capability	type="das1:unknown-feature"	/>
				<capability	type="das1:sequence"	/>
				<capability	type="das1:maxbins"	/>
				<capability	type="das1:entry_points"	/>
			</version>

            <dna-command-enabled>true</dna-command-enabled>
            <use-feature-id-for-feature-label>true</use-feature-id-for-feature-label>
            <include-types-with-zero-count>true</include-types-with-zero-count>
        </datasource>

}}}
Notice that besides `sequence` we have also include the capabilities `maxbins` and `entry_points` that will be developed further in this tutorial.

Now you can get the sequence of the chromosomes:
  * [http://localhost:8080/das/ensemblReferenceTest/sequence?segment=5]
  * [http://localhost:8080/das/ensemblReferenceTest/sequence?segment=x]
  * [http://localhost:8080/das/ensemblReferenceTest/sequence?segment=unknown]

== `entry points` Capability ==

Some times it is important to provide the ids of the complete segments that can be accessed in a data source. This is specially remarkable for reference servers, in order to bring an easy way to let the user/client to know what can be found in this data source. Usually the entry points are the Uniprot ids for protein data sources and chromosomes/contigs/genes for genomic data sources.

Developing an annotation data source implies to implement the methods `getEntryPoints`, `getEntryPointVersion` and `getTotalEntryPoints` as seen here:

{{{
	public Collection<DasEntryPoint> getEntryPoints(Integer start, Integer stop) 
		throws UnimplementedFeatureException, DataSourceException {
	}
	public String getEntryPointVersion() 
		throws UnimplementedFeatureException, DataSourceException {
	}
	public int getTotalEntryPoints() 
		throws UnimplementedFeatureException, DataSourceException {
	}
}}}

In the previous tutorial we have just throw the corresponding exception to inform that this capability have not been implemented. Here we will see that this implementation can be very simple. To start we can use the version of the database we are using as the version for the entry points, in other cases it may be use the date of publication, etc. so, in the `EnsemblTestManager.java` file we should put the database as a private String attribute and provide a public getter method for it:
{{{
	private String database = "homo_sapiens_core_56_37a";

	public String getDatabase(){
		return database;
	}
}}}
And in the file `EnsemblTestReferenceDatasource.java` the `getEntryPointVersion` method should be overwritten as:
{{{
	public String getEntryPointVersion() throws UnimplementedFeatureException, DataSourceException {
		return ensembl.getDatabase();
	}
}}}

The entry points of our data source are the chromosomes available. Besides the regular chromosomes(1-22 + X + Y) Ensembl database includes other structures of this level, for instance the mitochondrial chromosome. To get this list we have to query the `seq_region` in its chromosomal scope which is the coordinate system 2. The SQL is:
{{{
SELECT * FROM seq_region WHERE seq_region.coord_system_id =2;
}}}
This SQL will be located in the class `EnsemblTestManager.java` in a method called `getEntryPoints`. We will create a private attribute to store in memory the list of entry points, in this way the query will be executed just once, and the next time an entry point request is received can be obtained from memory. The code to add is:
{{{
	private Collection<DasEntryPoint> entryPoints=null;

	public Collection<DasEntryPoint> getEntryPoints() throws DataSourceException{
		if (entryPoints!=null)
			return entryPoints;
		String sql="";
		sql="SELECT * FROM seq_region WHERE seq_region.coord_system_id =2;";
		try {
			Statement s = connection.createStatement ();
			s.executeQuery (sql);
			ResultSet rs = s.getResultSet ();
			entryPoints = new ArrayList<DasEntryPoint>();
			while (rs.next ()) {
				entryPoints.add(new DasEntryPoint(rs.getString("name"), 1, rs.getInt("length"), "Chromosome", getDatabase(), DasEntryPointOrientation.NO_INTRINSIC_ORIENTATION, "Chromosome", true));
			}
			rs.close ();
			s.close ();
		} catch (SQLException e) {
			throw new DataSourceException("Problems executing the sql query",e);
		}
		return entryPoints;
	}
}}}
instances of the entry points are being created at the same moment to added in the list in the line:
{{{
entryPoints.add(new DasEntryPoint(rs.getString("name"), 1, rs.getInt("length"), "Chromosome", getDatabase(), DasEntryPointOrientation.POSITIVE_ORIENTATION, "is a chromosome", true));
}}}
We are calling the constructor of the DasEntryPoint providing the next values:
  * segmentId -> rs.getString("name") : value obtained from the DB for the name of the chromosome.
  * startCoordinate -> 1 : we assume all the chromosomes starts in the position 1. It might be a false assumption in the case of the clone chromosomes or cases like that.
  * stopCoordinate -> rs.getInt("length") : given the previous assumption the stop coordinate is equivalent to the length of the chromosome.
  * type -> "Chromosome" : We are not specifying the types of chromosomes that we are returning
  * version -> getDatabase() : Re-using the method to get the database that we are using which implies the version of Ensemble release that we are using.
  * orientation -> DasEntryPointOrientation.POSITIVE_ORIENTATION : just to express that at chromosomal level the sequence is always given in the positive direction.
  * description -> "is a chromosome" : free description of the entry point, could be more elaborated and include the id and its coordinates.
  * hasSubparts -> true : just to recall the fact that when we define this datasource we define the contigs as parts of the chromosome

The last method we have to implement is getTotalEntryPoints, which is specially important in data sources with many entry points because !MyDas uses this method for validation of the range for the pagination of entry points. An easy way to implement this in our data source is:
{{{
	public int getTotalEntryPoints() throws UnimplementedFeatureException, DataSourceException {
		return ensembl.getEntryPoints().size();
	}
}}}


== `maxbins` Capability ==

Often a DAS client is limited to display a number of features when in reality a segemnt can have a lot more; think for example, in a client displaying the chromosome 1 and wanted to show its genes as its annotations, there are around 4200 genes in this chromosome, a popular screen configuration have 1280x1024 pixeles, therefore it is phisically impossible to draw all the genes in the same track for this chormosome.
The DAS capability *maxbins* allow to request a X number of the most representative features in a segment.
The problem is that just the owner of the data source can define what 'representative' means for their data. For instance in the case of the genes, a medical related database migth want to prioritize genes connected with a disease, but a different data source can define its discriminating criterion in a very different way.

As seen in previous tuturials the methods to implement in !MyDas in order to get the features of a segment are defined as:
{{{
	public DasAnnotatedSegment getFeatures(String segmentId, Integer maxbins)
		throws BadReferenceObjectException, DataSourceException {
	}

	public Collection<DasAnnotatedSegment> getFeatures(Collection<String> featureIdCollection, Integer maxbins)
		throws UnimplementedFeatureException, DataSourceException {
	}

}}}

In both cases there is an Integerattribute called -maxbins-, this value indicates how many features the client wants to receive for the requested segment, and again is decision of the datasource how to choose the response set.