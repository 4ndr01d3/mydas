#summary how to implement a reference server + entry points and maxbins capabilities
#labels Phase-Support

= !MyDas Tutorial - Other Capabilities =

In this tutorial we will explain how to create a reference data source that implements other capabilities included in DAS but that are optional, and because of that have been ignored in the other tutorials. This tutorial assumes that you have comleted the [MyDASTutorial3rdPart Advanced Tutorial] some of the methods developed there are going to be reused here.

== A reference Server ==

!MyDas also allows to implement a data source that provides the sequence as a reference for other data sources, including itself because in !MyDas a reference server it is by inheritance an annotation data source.

Let's start by making a copy of the data source created in the [MyDASTutorial3rdPart Advanced Tutorial], call it EnsemblTestReferenceDataSource.java 
Change the Interface to implement from RangeHandlingAnnotationDataSource to ReferenceDataSource:

{{{
public class EnsemblTestReferenceDataSource implements ReferenceDataSource
}}}

This interfase force us to implement the method `getSequence`:
{{{
	public DasSequence getSequence(String segmentId) throws BadReferenceObjectException, DataSourceException {
		return null;
	}
}}}

To get the sequence we have to query the database, therefore we will edit the Java class that is controlling the DB connection: EnsemblTestManager.java; Create a new method called getSequence with a signature as:
{{{
public DasSequence getSequence(String segmentId)
}}}
The sequence information in the Ensembl database is in the table `dna` but it requires the `seq_region_id` which in tha case of chromosomes can be found in the table seq_region with a query like `SELECT * FROM seq_region WHERE coord_system_id = 2;`; from there we can create a combined SQL like:
{{{
SELECT * FROM chromosome WHERE name=5;
}}}
And then our method will be something like:
{{{
	public DasSequence getSequence(String segmentId) throws DataSourceException, BadReferenceObjectException {
		DasSequence seq=null;
		String sql="";
		sql="SELECT * FROM chromosome WHERE name="+segmentId;
		try {
			Statement s = connection.createStatement ();
			s.executeQuery (sql);
			ResultSet rs = s.getResultSet ();
			if (rs.next ()) {
				seq= new DasSequence(segmentId,rs.getString("SEQUENCE"),1,"homo_sapiens_core_56_37a", "Chromosome "+segmentId);
			}else{
				throw new BadReferenceObjectException("The segment ["+segmentId+"] was not found in this reference server", segmentId);
			}
			rs.close ();
			s.close ();
		} catch (SQLException e) {
			throw new DataSourceException("Problems executing the sql query",e);
		}
		return seq;
	}

}}}

And then, the implementation of the method in the data source is as simple as:
{{{
	public DasSequence getSequence(String segmentId) throws BadReferenceObjectException, DataSourceException {
		return ensembl.getSequence(segmentId);
	}
}}}

Now that we have this is just a matter of registering this data source in the MyDas configuration file, as in previous examples edit the file `[MyDasTemplate]/src/main/webapp/MydasServerConfig.xml` and add a data source. The added data source should look similar to:
{{{
        <datasource uri="ensemblReferenceTest"
                    title="ensemblReferenceTest"
                    description="Reference data source from ensembl database"
                    doc_href="http://mydas.googlecode.com/svn/trunk/mydas/MyDasTemplate/src/main/java/uk/ac/ebi/mydas/examples">
			<maintainer email="youremail@server.com" />

			<version uri="ensemblReferenceTest" created="2011-02-08">
	            <class>uk.ac.ebi.mydas.examples.EnsemblTestReferenceDatasource</class>
				<coordinates 	uri="CS_DS94"
								source="Gene_ID"
								authority="Ensembl"
								taxid="9606"
								test_range="ENSG00000160916">Ensembl,Gene_ID,Homo sapiens</coordinates>
				<capability	type="das1:sources"
						query_uri="http://localhost:8080/das/examplegff" />
				<capability	type="das1:types"
						query_uri="http://localhost:8080/das/examplegff/types" />
				<capability	type="das1:features"
						query_uri="http://localhost:8080/das/examplegff/features" />
				<capability	type="das1:feature-by-id"
						query_uri="http://localhost:8080/das/examplegff/features" />
				<capability	type="das1:stylesheet"
						query_uri="http://localhost:8080/das/examplegff/stylesheet" />
				<capability	type="das1:unknown-feature"	/>
				<capability	type="das1:sequence"	/>
				<capability	type="das1:maxbins"	/>
				<capability	type="das1:entry_points"	/>
			</version>

            <dna-command-enabled>true</dna-command-enabled>
            <features-strictly-enclosed>true</features-strictly-enclosed>
            <use-feature-id-for-feature-label>true</use-feature-id-for-feature-label>
            <include-types-with-zero-count>true</include-types-with-zero-count>
        </datasource>

}}}
Notice that besides `sequence` we have also include the capabilities `maxbins` and `entry_points` that will be developed further in this tutorial.

Now you can get the sequence of the chromosomes:
  * [http://localhost:8080/das/ensemblReferenceTest/sequence?segment=5]
  * [http://localhost:8080/das/ensemblReferenceTest/sequence?segment=x]
  * [http://localhost:8080/das/ensemblReferenceTest/sequence?segment=unknown]

== `entry points` Capability ==

Some times it is important to provide the ids of the complete segments that can be accessed in a data source. This is specially remarkable for reference servers, in order to bring an easy way to let the user/client to know what can be found in this data source. Usually the entry points are the Uniprot ids for protein data sources and chromosomes/contigs/genes for genomic data sources.

Developing an annotation data source implies to implement the methods `getEntryPoints`, `getEntryPointVersion` and `getTotalEntryPoints` as seen here:

{{{
	public Collection<DasEntryPoint> getEntryPoints(Integer start, Integer stop) 
		throws UnimplementedFeatureException, DataSourceException {
	}
	public String getEntryPointVersion() 
		throws UnimplementedFeatureException, DataSourceException {
        }
	public int getTotalEntryPoints() 
		throws UnimplementedFeatureException, DataSourceException {
	}
}}}

== `maxbins` Capability ==

Often a DAS client is limited to display a number of features when in reality a segemnt can have a lot more; think for example, in a client displaying the chromosome 1 and wanted to show its genes as its annotations, there are around 4200 genes in this chromosome, a popular screen configuration have 1280x1024 pixeles, therefore it is phisically impossible to draw all the genes in the same track for this chormosome.
The DAS capability *maxbins* allow to request a X number of the most representative features in a segment.
The problem is that just the owner of the data source can define what 'representative' means for their data. For instance in the case of the genes, a medical related database migth want to prioritize genes connected with a disease, but a different data source can define its discriminating criterion in a very different way.

As seen in previous tuturials the methods to implement in !MyDas in order to get the features of a segment are defined as:
{{{
	public DasAnnotatedSegment getFeatures(String segmentId, Integer maxbins)
		throws BadReferenceObjectException, DataSourceException {
	}

	public Collection<DasAnnotatedSegment> getFeatures(Collection<String> featureIdCollection, Integer maxbins)
		throws UnimplementedFeatureException, DataSourceException {
	}

}}}

In both cases there is an Integerattribute called -maxbins-, this value indicates how many features the client wants to receive for the requested segment, and again is decision of the datasource how to choose the response set.